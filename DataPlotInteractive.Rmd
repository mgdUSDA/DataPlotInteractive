---
title: "DataPlotInteractive"
author: "mdusaire"
date: "May 2, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

### Pre-process data before plotting.  The 3 data file formats are called:  Arduino, Cozir-Arduino, XYZ

#### Cozir-Arduino data collected using cozirReader18.02 is in the correct format and does not require pre-processing.

#### Pre-processing Arduino data.

```{r libraries}

library(ggplot2)
library(tidyr)
```

```{r arduino data}

# rm(list = ls())

infile <- "D:/T3620 dusaire/Arduino/rsmt/051418A BCPlots.txt"

infile <- gsub("\\\\", "/", infile)
fName <- paste("/", strsplit(infile, "/")[[1]][length(strsplit(infile, "/")[[1]])], sep = "")
dataFolder <- strsplit(infile, fName)[[1]][1]
idBase <- strsplit(fName, ".csv")[[1]][1]
idBase <- gsub("/", "", idBase)

rd <- read.csv(infile, header = TRUE, as.is = TRUE, strip.white = TRUE, blank.lines.skip = TRUE, na.strings = c("NA", "INF"))

# When the Arduino program is launched it may collect INF or other non-data if the sensors or program did not initialize correctly.  Remove these rows of non-data.

rd <- na.omit(rd)
rd <- cbind(rd, id = NA, time = NA)

# Test for INF data.
# which(rd == "INF", arr.ind = TRUE)[,"row"]

# The Arduino software writes column headers every time the program is launched.  Use column header location to break data into data blocks.

idBreaks <- which(rd[, 1] %in% colnames(rd))
rd[, 'time'] <- (as.numeric(rd[1:nrow(rd), 'millis']) - as.numeric(rd[1, 'millis'])) / 1000
if (length(idBreaks) > 0) {
  rd[, 'id'] <-  paste(idBase, "_1", sep ="")  
  for (i in 1:length(idBreaks)) {
    idStart <- idBreaks[i] + 1
    
    # fill id column
    
    rd[idStart:nrow(rd), 'id'] <- paste(idBase, "_", i + 1, sep = "")
    
    # fill time column
    
    rd[idStart:nrow(rd), 'time'] <- (as.numeric(rd[idStart:nrow(rd), 'millis']) - as.numeric(rd[idStart, 'millis'])) / 1000
  }
  
# Remove extra header rows
  
  rd <- rd[-idBreaks,]
} else {
  rd[, 'id'] <- idBase
}

for (i in 2:12) {
 rd[, i] <- as.numeric((rd[, i]))
}


for (i in 2:12) {
 rd[, i] <- rd[, i] / max(rd[, i], na.rm = TRUE)
}

 # Normalize readings

 rd_long <- gather(rd, key = measure, value = reading, NH3:Temperature, -datetime, -millis, -time)
 

 
 
 
 write.csv(rd_long, "D:/T3620 dusaire/Arduino/rsmt/DPI.csv")
 
```

## Including Plots
```{r plots}
plotData <- rd_long
#plotData <- subset(rd_long, select = NH3)


g <- ggplot(data = plotData, aes(x = time, y = reading, color = measure, shape = id)) +
      geom_point(size = 2.5) +
      # scale_shape_manual(values = c(0:18)) +
      # scale_colour_manual(values = pColors()) +
      # coord_cartesian(xlim = time, ylim = ranges$y) +
      # xlab(paste(input$xcol, " (", mUnits()[time], ")", sep = "")) +
      ggtitle(paste("Data for", fName))

print(g)
```

```{r stats}

rdVar <- subset(rd, select = NH3:Temperature)

cor(rdVar)

pairs(rdVar)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
